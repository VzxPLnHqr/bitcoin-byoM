package byom.ecc

import cats._
import cats.implicits._

/**
 * A finally tagless representation of some elliptic curve algorithms
 * 
 *  y^2 = x^3 + a*x + b  mod p
 * 
 * 
 * */
trait Curve[F[_]] {
    sealed trait ECCPoint
    final case class CurvePoint(x: BigInt, y:BigInt) extends ECCPoint
    case object PointAtInfinity extends ECCPoint

    def curveName: F[String]
    def _p: F[BigInt]  // the modulus of the finite field
    def _a: F[BigInt] // the a coefficient
    def _b: F[BigInt] // the b coefficient
    def G: F[CurvePoint] // the generator point G
    def _n: F[BigInt] // the order of the group generated by G
}

abstract class curveOpsM[F[_] : Curve : Monad] {
    val curve : Curve[F] = implicitly

    def isPointAtInfinity(point: F[Curve[F]#ECCPoint]): F[Boolean]

    def pointDouble( point: F[Curve[F]#ECCPoint]): F[Curve[F]#ECCPoint] = for {
        pt <- point
        a <- curve._a
        p <- curve._p
        r = pt match {
            case curve.PointAtInfinity => pt
            case curve.CurvePoint(x,y) =>
                val L = (  ((BigInt(3) * x.pow(2)) + a) * ((BigInt(2) * y)).modInverse(p) ).mod(p)
                val x_new = (L.pow(2) - x - x).mod(p)
                val y_new = (L*(x - x_new) - y).mod(p)
                curve.CurvePoint(x_new, y_new)
        }
    } yield r

}

object Curve {
   
   def apply[F[_] : Curve]: Curve[F] = implicitly

}
